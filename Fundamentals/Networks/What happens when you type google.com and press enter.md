This contains more info beyond just the network aspect of things but generally useful. Based on this [Github page](https://github.com/alex/what-happens-when)

## "g" key pressed
- Browser receives event, autocomplete functions kick in
	- Depending on browser algo and whether you're in incognito, various suggestions will appear
	- Algos prioritize search history, bookmarks, cookies, popular searches

## "Enter" key bottoms out
- Hardware portion
	- Electrical circuit specific to key closed, causing current to flow into logic circuits of keyboard
	- Keyboard scans state of each key switch, debounces electrical noise of rapid intermittent closure of switch, converts it into keycode integer 13
	- Keyboard controller encodes keycode for transport to computer over USB/ Bluetooth
	- For USB
		- endpoint: Register that stores keycode generated by keyboard logic circuits
		- Host USB controller polls endpoint every ~10ms to get keycode value
		- Value goes to USB Serial Interface Engine (SIE) to be converted into USB packets that follow USB protocol
		- Packets sent by electrical signal over D+ and D- pins at max speed of 1.5Mb/s, as a Human Interface Device (HID) is always declared to be low-speed (USB 2.0 compliance)
		- Serial signal decode by computer's host USB controller, interpreted by computer's HID keyboard device driver
		- Value of key passed to OS 
	- Virtual keyboards (touch screen devices)
		- Finger on capacitive touch screen completes circuit by current through finger, creating voltage drop
		- Screen controller raises interrupt reporting coordinates of keypress
		- Virtual keyboard raises a software interrupt for sending key pressed message back to OS
		- Interrupt notifies currently focused app of key pressed event
		- Interrupt fires on interrupt request line (IRQ) which is mapped to interrupt vector by interrupt controller
		- When interrupt arrives, CPU indexes IDT with interrupt vector and runs appropriate handler. CPU uses Interrupt Descriptor Table (IDT) to map interrupt vectors to functions (interrupt handlers) supplied by kernel 
- OS portion
	- Windows 
		- In kernel mode,
			- `WM_KEYDOWN` message sent to app
			- HID transport passes event to keyboard HID `KBDHID.sys` driver, converting HID usage into scancode `VK_RETURN` (`0x0D`). 
			- `KBDHID.sys` interfaces with Keyboard Class driver `KBDCLASS.sys` which then calls `Win32K.sys`
			- `Win32K.sys` figures out active window using `GetForegroundWindow()` API, which provides window handle of browser's address box
			- Main Windows message pump calls `SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam)`
				- `lParam`: bitmask indicating further info about keypress: repeat count, actual scan code (generally wont be `VK_RETURN`, whether extended keys (alt, ctrl) were pressed, and some other state)
			- Windows `SendMessage` API adds message to queue for window handle `hWnd`
			- Later, main message processing function `WindowProc` assigned to `hWnd` is called to process each message in queue
			- The window (`hWnd`) that's active is an edit control and `WindowPRoc` has a message handler for `WM_KEYDOWN` messages
				- Code looks within `wParam` (`SendMessage(..., ..., wParam, ...)`) and because its `VK_RETURN` knows user has hit ENTER key
	- OS X
		- `KeyDown` NSEvent sent to app
		- interrupt signal triggers interrupt event in I/O Kit kext keyboard driver
		- Driver translates signal into key code which passes to OS X `WindowServer` process
		- `WindowServer` dispatches event to appropriate app through Mach port where its placed into an event queue
		- Events are then read from queue by thread with sufficient privileges calling the `mach_ipc_dispatch` function
		- Most commonly occurs through and is handled by an `NSApplication` main event loop via `NSEvent` of `NSEventType` `KeyDown`
	- Linux
		- When graphical `X server` is used, `X` will use generic event driver `evdev` to acquire keypress
		- Re-mapping of keycodes to scancodes is made with `X server` specific keymaps and rules
		- When scancode mapping of key pressed is complete, `X server` sends character to `window manager`, so `window manager` in turn sends character to focused window
		- Graphical API that receives the character prints appropriate font symbol in appropriate focused field
## Brower portion
- **Parse URL**
		- Browser now has info contained in URL
		- When no protocol or valid domain name given, browser feeds text to default search engine. In many cases URL has special text appended to it to tell search engine that it came from particular browser's URL bar
- **Convert non-ASCII Unicode characters**
	- Browser checks for characters that are non-ASCII
	- if this exists, browser would apply Punycode encoding to hostname portion of URL
		- **Punycode:** Representation of Unicode with ASCII for internet hostnames e.g. _MÃ¼nchen_ $\rightarrow$ _Mnchen-3ya_
## Network portion
- **Check HSTS list**
	- Browser checks preloaded HSTS (HTTP Strict Transport Security) list (list of websites that have requested to be contacted via HTTPS only)
	- If website on list, browser sends request via HTTPS instead of HTTP
	- Else, initial request sent via HTTP 
	- Website can use HSTS policy without being on HSTS list; first HTTP request will receive response requesting user only send HTTPS (but this leaves user vulnerable to Man-in-the-middle attack)
		- MITM attacker intercepts HTTP, making it appear as if HTTPS isn't supported by website, then capturing and modifying unencrypted traffic
- **DNS Lookup**
	- Browser checks if domain in cache 
	- If not, browser calls `gethostbyname` library function (varies by OS) to do lookup
	- `gethostbyname` checks if hostname can be resolved by reference in local `hosts` file before trying to resolve hostname through DNS
	- If `gethostbyname` has a cache miss or can't find it in `hosts` file, it makes request to DNS server configured in network stack; This is typically local router or ISP's caching DNS server
	- If DNS server is on same subnet, network library follows `ARP process` for DNS server
	- If DNS server on different subnet, network library follows `ARP process` for default gateway IP
- **Address Resolution Protocol (ARP) Process**
	- To send ARP broadcast, network stack library needs:
		- target IP address to lookup
		- MAC address of interface to send out ARP broadcast 
	- ARP cache is first checked for ARP entry for target IP. If its in cache, function returns `target_ip = MAC`
	- If entry not in ARP cache
		- route table looked up to see if `target_ip` address is on any of the subnets on local route table
			- if it is, library uses interface associated with subnet
			- if not, library uses interface that has subnet of our default gateway
	- MAC address of selected network interface is looked up
	- Network library sends a layer 2 `ARP request`
```
Sender MAC: interface:mac:address:here
Sender IP: interface.ip.goes.here
Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
Target IP: target.ip.goes.here
```
- 
	- If hardware between computer and router directly connected with a:
		- Hub:
			- If computer is connected to hub, hub will broadcast ARP request out of all other ports
			- If router is connected on same "wire", it will respond with an `ARP Reply`
		- Switch:
			- If computer connected to switch, switch will check local CAM/ MAC table to see which port has target MAC address 
				- If switch has no entry for MAC address, it will rebroadcast ARP request to all other ports
				- If switch has entry in MAC/ CAM table, it will send ARP request to port that has targeted MAC address
			- If router is on same "wire", it will respond with an `ARP Reply`
```
Sender MAC: target:mac:address:here
Sender IP: target.ip.goes.here
Target MAC: interface:mac:address:here
Target IP: interface.ip.goes.here
```
- 
	- Now that network library has IP address of either DNs server or default gateway, it can resume DNS process
		- DNS client establishes socket to UDP port 53 on DNS server, using source port above 1023
		- If response size too large, TCP will be used instead
		- If local/ ISP DNS server does not have it, recursive search requested and that flows up the list of DNS servers until SOA is reached, and if found answer is returned

- **Opening Socket**
	- Once browser receives IP address of destination server, it takes that and given port number from URL and makes a call to system library function `socket` and requests a TCP socket stream (`AF_INET/AF_INET6` and `SOCK_STREAM`)
	- Request first passed to Transport layer where TCP segment is crafted. Destination port added to header, and source port is chosen from within kernel's dynamic range (`ip_local_port_range` in Linux)
	- This segment is sent to Network Layer, which wraps an additional IP header. IP address of destination server as well as that of current machine is inserted to form packet
	- Packet then arrives at Link layer. Frame header is added that includes MAC address of machine's Network Interface Card (NIC) as well as MAC address of gateway (local router). If kernel does not know MAC address of gateway, it must broadcast an ARP query to find it
	- Packet is now ready to be transmitted through Ethernet, Wifi, or Cellular data

	- For most home/small business internet connections, packet will pass from computer, through a local network, then through modem converting digital signals into analog suitable for transmission over telephone/ cable connections. On other end is another modem converting analog back to digital to be processed by next network node where the from and to addresses would be analyzed further
	- For larger businesses/ new residential connections, they will have fiber/ direct ethernet connections to pass data to next network node without conversion to analog

	-  Packet eventually reaches router managing local subnet, where it then travels to the autonomous system's (AS) border routers, other ASes, and finally destination server
		- Each router along the way extracts destination address from IP header and routes it to appropriate next hop
		- Time To Live (TTL) field in IP header decremented by one for each router passed. Packet will be dropped if TTL field reaches 0 or if current router has no space in queue
		- Send and Receive follows [[Transmission Control Protocol (TCP)]] connection flow

- **Transport Layer Security (TLS) Handshake**
	- Client sends `ClientHello` message to server with its TLS version, list of cipher algos and compression methods available
	- Server replies with `ServerHello` message to client with TLS version, selected cipher, selected compression methods, and server's public certificate signed by a Certificate Authority (CA). Certificate contains public key that will be used by client to encrypt rest of handshake until symmetric key can be agreed upon
	- Client verifies server digital certificate against list of trusted CAs
		- If trust can be established based on CA, client generates string of pseudo-random bytes and encrypts bytes with server's public key. Random bytes can be used for determining the symmetric key
	- Server decrypts random bytes using private key and uses bytes to generates its copy of symmetric master key
	- Client sends `Finished` message to server, encrypting hash of transmission up to this point with symmetric key
	- Server generates its own hash, then decrypts client-sent hash to verify its match
		- If it does, server sends its own `Finished` message to client, also encrypted with symmetric key
	- TLS session now transmits app data encrypted with agreed symmetric key
- **If packet is dropped**
	- Due to network congestion/ flaky hardware connections, TLS packets might be dropped before getting to final destination
	- Algo for deciding sender's reaction is called [[TCP Congestion Control]] and varies depending on sender
	- Most common algos are cubic on newer OSes and New Reno on almost all others
		- Client chooses congestion window based on max segment size (MSS) of connection
		- For each packet ACKed, window doubles in size until it reaches 'slow-start threshold'. For some implementations, threshold is adaptive
		- Window then increases additively for each packet ACKed. If packet dropped, window reduces exponentially until another packet ACKed
- **HTTP Protocol**
	- Browser sends HTTP request to retrieve page
```
GET /HTTP/{VERSION}
Host: google.com
Connection: close
[other headers]
```
- 
	- Server responds with response code denoting status of request, followed by single newline and payload of HTML content of google.com
	- Server may then either close connection, or if headers sent by client request it, keep connection open
	- If HTTP headers sent by browser included sufficient info for server to determine if version of file cached by web browser has been unmodified since last retrieval (i.e. browser included `ETag` header), it may respond with request of form `304 Not Modified` and no payload, and browser instead retrieves HTML from cache
	- After parsing HTML, browser repeats process for every resource referenced by HTML page, with slight differences in syntax (`GET /$(relative_URL) HTTP/1.1`)
- **HTTP Server Request Handle**
	- HTTPD (HTTP Daemon) server is handling requests/responses on server-side
		- Most common HTTPD servers are Apache or nginx for Linux and IIS for Windows
	- HTTPD receives request
	- Server breaks request to following params
		- [[HTTP]] Request method 
		- Domain
		- Requested path/page
	- Server verifies that there is a Virtual Host configured on server that corresponds with `google.com`
	- Server verifies that `google.com` can accept GET requests
	- Server verifies that client is allowed to use this method (by IP, authentication, etc)
	- If server has rewrite module installed, it tried to match request against configured rules. If matching rule is found, server uses that rule to rewrite request
	- Server goes to pull content that corresponds with request (for `google.com` this will fall back to the index file as "/" is main file)
	- Server parses file according to handler. If Google is running on PHP, server uses PHP to interpret index file and streams output to client

## Browser behind the scenes
Browser parses HTML, CSS, JS once supplied by server and renders this on user's screen

- Main components
	- User Interface (UI): UI includes every part of browser display except the window where you see the requested page
	- Browser engine: Engine marshals actions between UI and rendering engine
	- Rendering engine: Responsible for displaying requested content e.g. parsing requested HTML and CSS and displaying parsed content on screen
	- Networking: Handles network calls 
	- UI backend: For drawing basic widgets like combo boxes and windows. Exposes generic interface that is not platform-specific while using OS UI methods underneath
	- JavaScript Engine: Parse and execute JS code
	- Data storage: Persistence layer for saving data locally, such as cookies. Browsers also support storage mechanisms like localStorage, IndexedDB, WebSQL and FileSystem
- HTML Parsing
	- Rendering engine starts getting contents of requested document from networking layer in 8kB chunks
	- Primary job of parser is to parse HTML markup into a parse tree
	- Parse tree is tree of Document Object Model (DOM) element and attribute nodes
		- DOM is object presentation of HTML document and interface of HTML elements to outside world 
		- root of tree is "Document" object
		- Prior to scripting manipulation, DOM has almost 1-1 relation to markup
	- HTML Parsing algo
		- HTML cannot be parsed by regular top-down/ bottom-up parsers because
			- HTML is a forgiving language
			- Browsers have traditional error tolerance to support well known cases of invalid HTML
			- Parsing process is reentrant i.e. dynamic code can add extra tokens so parsing process actually modifies input
		- Consists of 2 stages:
			- Tokenization 
			- Tree Construction
		- Once parsing done, browser fetches external resources, marks document as interactive and starts parsing scripts that are in "deferred" mode: those that should be executed after document is parsed. Document state is set to "complete" and a "load" event is fired
	- CSS Interpretation
		- Parse CSS files, `<style>` tag contents, and `style` attributes
		- Each CSS file parsed into `StyleSheet object`, where each object contains CSS rules with selectors and objects corresponding CSS grammar
		- CSS parser can be top-down/ bottom-up
	- Page Rendering
		- Create 'Frame Tree'/ 'Render Tree' by traversing DOM nodes, calculating CSS style values for each node
		- Calculate preferred width of each node in 'Frame Tree' bottom-up by summing preferred width of child nodes and node's horizontal margins, borders and padding
		- Calculate actual width of each node top-down by allocating each node's avail width to its children 
		- Calculate height of each node bottom-up by applying text wrapping and summing child node heights and node's margins, borders and padding
		- Calculate coordinates of each node using info calculated above
		- Create layers to describe which parts of page can be animated as group without being re-rasterized. Each frame/ render object is assigned to layer
		- Textures allocated for each layer of the page
		- Frame/render objects for each layer are traversed and drawing commands are executed for their respective layer. May be rasterized by CPU or drawn on GPU directly using D2D/ SkiaGL
		- All steps may reuse calculated values from last render to reduce repeated work
		- Page layers sent to compositing process where they are combined with other features of browser
		- Final layer positions are computed and composite commands are issued via Direct3D/OpenGL. GPU command buffer(s) are flushed to GPU for async rendering and frame is sent to window server